 # Пользовательские директивы

## Содержание

1. [Создание директив на основе классов](#создание-директив-на-основе-классов)
2. [Жизненный цикл директивы на основе класса](#жизненный-цикл-директивы-на-основе-класса)
    1. [Однократная настройка: конструктор()](#однократная-настройка-конструктор)
    2. [Декларативный рендеринг: render()](#декларативный-рендеринг-render)
    3. [Императивный доступ к DOM: update()](#императивный-доступ-к-dom-update)
    4. [Отличия между update() и render()](#отличия-между-update-и-render)
3. [Сигнализирование об отсутствии изменений](#сигнализирование-об-отсутствии-изменений)
4. [Ограничение директивы одним типом выражений](#ограничение-директивы-одним-типом-выражений)
5. [Асинхронные директивы](#асинхронные-директивы)

Директивы — это функции, которые могут расширять возможности @metafor/html, настраивая, как выражение шаблона рендерится. Директивы полезны и мощны, поскольку они могут иметь состояние, обращаться к DOM, получать уведомления при
отключении и повторном подключении шаблонов, а также независимо обновлять выражения вне вызова render.

Использовать директиву в вашем шаблоне так же просто, как вызвать функцию в выражении шаблона:

```javascript
const template = html`
  <div>${fancyDirective("some text")}</div>
`
```

@metafor/html поставляется с рядом встроенных директив таких как `repeat()` и `cache()`. Пользователи также могут писать свои
собственные пользовательские директивы.

Существует два вида директив:

- Простые функции
- Директивы на основе классов

### Простые функции

Простая функция возвращает значение для рендеринга. Она может принимать любое количество аргументов или не принимать их вообще.

```javascript
export const noVowels = str => str.replaceAll(/[aeiou]/gi, "x")
```

### Директивы на основе классов

Директива на основе класса позволяет выполнять действия, которые простая функция не может. Используйте директиву на основе класса для:

- Прямого доступа к отрендеренному DOM (например, добавления, удаления или перестановки узлов DOM).
- Сохранения состояния между рендерами.
- Асинхронного обновления DOM вне вызова render.
- Очистки ресурсов при отключении директивы от DOM.

Остальная часть этой страницы описывает директивы на основе классов.

## Создание директив на основе классов

Чтобы создать директиву на основе класса:

1. Реализуйте директиву как класс, который расширяет класс Directive
2. Передайте ваш класс в фабрику directive(), чтобы создать функцию директивы, которая может использоваться в выражениях шаблонов Lit.

```javascript
import {Directive, directive} from "@pkg/html/directive.js"

// Определение директивы
class HelloDirective extends Directive {
  render() {
    return `Hello!`
  }
}

// Создание функции директивы
const hello = directive(HelloDirective)

// Использование директивы
const template = html`
  <div>${hello()}</div>
`
```

Когда этот шаблон оценивается, функция директивы (`hello()`) возвращает объект `DirectiveResult`, который инструктирует @metafor/html создать или обновить экземпляр класса директивы (`HelloDirective`). Затем @metafor/html вызывает методы
экземпляра директивы для выполнения логики обновления.

Некоторые директивы должны обновлять DOM асинхронно, вне обычного цикла обновления. Чтобы создать **асинхронную директиву**, расширьте базовый класс `AsyncDirective` вместо `Directive`.
См. [Асинхронные директивы](#асинхронные-директивы) для подробностей.

## Жизненный цикл директивы на основе класса

Класс директивы имеет несколько встроенных методов жизненного цикла:

- Конструктор класса для однократной инициализации.
- `render()`, для декларативного рендеринга.
- `update()`, для императивного доступа к DOM.

Необходимо реализовать обратный вызов `render()` для всех директив. Реализация `update()` является необязательной. В стандартной реализации `update()` вызывает и возвращает значение из `render()`.

Асинхронные директивы, которые могут обновлять DOM вне нормального цикла обновления, используют дополнительные методы жизненного цикла. См. [Асинхронные директивы](#асинхронные-директивы) для подробностей.

### Однократная настройка: конструктор()

Когда @metafor/html впервые сталкивается с `DirectiveResult` в выражении, он создаст экземпляр соответствующего класса директивы (что вызовет конструктор директивы и любые инициализаторы полей класса):

```typescript
class MyDirective extends Directive {
  // Поля класса инициализируются один раз и могут использоваться для сохранения
  // состояния между рендерами
  value = 0

  // Конструктор выполняется только первый раз, когда директива используется
  // в выражении
  constructor(partInfo: PartInfo) {
    super(partInfo)
    console.log("MyDirective создана")
  }

  // ...
}
```

Пока в каждом рендере используется та же функция директивы в том же выражении, предыдущий экземпляр повторно используется, и состояние экземпляра сохраняется между рендерами.

Конструктор получает единственный объект `PartInfo`, который предоставляет метаданные о выражении, в котором была использована директива. Это может быть полезно для проверки ошибок в случаях, когда директива предназначена
только для использования в определенных типах выражений (см. [Ограничение директивы одним типом выражений](#ограничение-директивы-одним-типом-выражений)).

### Декларативный рендеринг: render()

Метод `render()` должен возвращать значение для рендеринга в DOM. Он может возвращать любое допустимое для рендера значение, включая другой `DirectiveResult`.

Кроме обращения к состоянию на экземпляре директивы, метод `render()` может также принимать произвольные аргументы, переданные в функцию директивы:

```javascript
const template = html`
  <div>${myDirective(name, rank)}</div>
`
```

Параметры, определенные для метода `render()`, определяют сигнатуру функции директивы:

```typescript
class MaxDirective extends Directive {
  maxValue = Number.MIN_VALUE

  // Определение метода render, который может принимать аргументы:
  render(value: number, minValue = Number.MIN_VALUE) {
    this.maxValue = Math.max(value, this.maxValue, minValue)
    return this.maxValue
  }
}

const max = directive(MaxDirective)

// Вызов директивы с аргументами `value` и `minValue`, определенными для `render()`:
const template = html`
  <div>${max(someNumber, 0)}</div>
`
```

### Императивный доступ к DOM: update()

В более сложных случаях ваша директива может потребовать доступа к базовому DOM и императивного чтения или изменения его. Это можно достичь путем переопределения обратного вызова `update()`.

Обратный вызов `update()` получает два аргумента:

1. Объект `Part` с API для прямого управления DOM, связанным с выражением.
2. Массив, содержащий аргументы `render()`.

Ваш метод `update()` должен возвращать что-то, что @metafor/html может отрендерить, или специальное значение `noChange`, если повторный рендеринг не требуется. Обратный вызов `update()` достаточно гибок, но типичные использования
включают:

- Чтение данных из DOM и использование их для генерации значения для рендеринга.
- Императивное обновление DOM с использованием ссылки `element` или `parentNode` на объекте `Part`. В этом случае `update()` обычно возвращает `noChange`, указывая, что @metafor/html не нужно предпринимать никаких дальнейших
  действий для рендеринга директивы.

#### Части

Каждая позиция выражения имеет свой собственный специфический объект `Part`:

- `ChildPart` для выражений в позиции дочернего элемента HTML.
- `AttributePart` для выражений в значении атрибута HTML.
- `BooleanAttributePart` для выражений в булевом значении атрибута (имя с префиксом `?`).
- `EventPart` для выражений в позиции слушателя событий (имя с префиксом `@`).
- `PropertyPart` для выражений в значении свойства (имя с префиксом `.`).
- `ElementPart` для выражений в теге элемента.

Кроме метаданных, специфичных для части, содержащихся в `PartInfo`, все типы `Part` предоставляют доступ к DOM-элементу `element`, связанному с выражением (или `parentNode` в случае `ChildPart`), который может быть
непосредственно доступен в `update()`. Например:

```typescript
// Отображает имена атрибутов родительского элемента в textContent
class AttributeLogger extends Directive {
  attributeNames = ""

  update(part: ChildPart) {
    this.attributeNames = (part.parentNode as Element).getAttributeNames()?.join(" ")
    return this.render()
  }

  render() {
    return this.attributeNames
  }
}

const attributeLogger = directive(AttributeLogger)

const template = html`
  <div a b>${attributeLogger()}</div>
`
// Отображает: `<div a b>a b</div>`
```

Кроме того, модуль `directive-helpers.js` включает ряд вспомогательных функций, которые работают с объектами `Part` и могут использоваться для динамического создания, вставки и перемещения частей внутри `ChildPart`
директивы.

#### Вызов render() из update()

Стандартная реализация `update()` просто вызывает и возвращает значение из `render()`. Если вы переопределяете `update()` и все же хотите вызвать `render()` для генерации значения, вам нужно вызвать `render()` явно.

Аргументы `render()` передаются в `update()` как массив. Вы можете передать аргументы в `render()` следующим образом:

```typescript
class MyDirective extends Directive {
  update(part: Part, [fish, bananas]: DirectiveParameters<this>) {
    // ...
    return this.render(fish, bananas)
  }

  render(fish: number, bananas: number) {
    // ...
  }
}
```

### Отличия между update() и render()

Хотя обратный вызов `update()` более мощный, чем `render()`, существует важное различие: при использовании пакета `@metafor/html/ssr` для серверного рендеринга (SSR) **только** метод `render()` вызывается на сервере. Чтобы
быть совместимыми с SSR, директивы должны возвращать значения из `render()` и использовать `update()` только для логики, требующей доступа к DOM.

## Сигнализирование об отсутствии изменений

Иногда директива может не иметь ничего нового для рендеринга. Вы сигнализируете об этом, возвращая `noChange` из метода `update()` или `render()`. Это отличается от возврата `undefined`, что заставляет @metafor/html очистить `Part`,
связанный с директивой. Возврат `noChange` оставляет ранее отрендеренное значение на месте.

Существует несколько распространенных причин для возврата `noChange`:

- На основе входных значений нет ничего нового для рендеринга.
- Метод `update()` обновил DOM императивно.
- В асинхронной директиве вызов `update()` или `render()` может вернуть `noChange`, потому что пока нечего рендерить.

Например, директива может отслеживать предыдущие значения, переданные ей, и выполнять собственную проверку "грязности", чтобы определить, нужно ли обновлять вывод директивы. Метод `update()` или `render()` может вернуть
`noChange`, чтобы сигнализировать, что вывод директивы не требует повторного рендеринга.

```typescript
import {Directive} from "@pkg/html/directive.js"
import {noChange} from "@pkg/html"

class CalculateDiff extends Directive {
  a?: string
  b?: string

  render(a: string, b: string) {
    if (this.a !== a || this.b !== b) {
      this.a = a
      this.b = b
      // Тщательный алгоритм дифференциации текста
      return calculateDiff(a, b)
    }
    return noChange
  }
}
```

## Ограничение директивы одним типом выражений

Некоторые директивы полезны только в одном контексте, например, в выражении атрибута или в дочернем выражении. Если директива используется в неправильном контексте, она должна выбросить соответствующую ошибку.

Например, директива `classMap` проверяет, что она используется только в `AttributePart` и только для атрибута `class`:

```typescript
class ClassMap extends Directive {
  constructor(partInfo: PartInfo) {
    super(partInfo)
    if (partInfo.type !== PartType.ATTRIBUTE || partInfo.name !== "class") {
      throw new Error("Директива `classMap` должна использоваться только в атрибуте `class`")
    }
  }

  // ...
}
```

## Асинхронные директивы

Приведенные выше примеры директив синхронны: они возвращают значения синхронно из своих методов жизненного цикла `render()`/`update()`, поэтому их результаты записываются в DOM во время обратного вызова `update()`
компонента.

Иногда вы хотите, чтобы директива могла обновлять DOM асинхронно — например, если она зависит от асинхронного события, такого как сетевой запрос.

Чтобы обновить результат директивы асинхронно, директива должна расширять базовый класс `AsyncDirective`, который предоставляет API `setValue()`. `setValue()` позволяет
директиве "вставлять" новое значение в выражение шаблона вне нормального цикла `update`/`render` шаблона.

Вот пример простой асинхронной директивы, которая рендерит значение Promise:

```typescript
class ResolvePromise extends AsyncDirective {
  render(promise: Promise<unknown>) {
    Promise.resolve(promise).then(resolvedValue => {
      // Асинхронно рендерится:
      this.setValue(resolvedValue)
    })
    // Синхронно рендерится:
    return `Ожидание разрешения промиса`
  }
}

export const resolvePromise = directive(ResolvePromise)
```

Здесь отрендеренный шаблон сначала показывает "Ожидание разрешения промиса", а затем отображает разрешенное значение промиса, когда он разрешается.

Асинхронные директивы часто должны подписываться на внешние ресурсы. Чтобы предотвратить утечки памяти, асинхронные директивы должны отписываться или освобождать ресурсы, когда экземпляр директивы больше не используется.
Для этого `AsyncDirective` предоставляет следующие дополнительные методы жизненного цикла и API:

- `disconnected()`: Вызывается, когда директива больше не используется. Экземпляры директив отключаются в трех случаях:

    - Когда дерево DOM, содержащее директиву, удаляется из DOM
    - Когда хост-элемент директивы отключается
    - Когда выражение, которое создавало директиву, больше не ссылается на ту же директиву

  После получения директивой обратного вызова `disconnected` она должна освободить все ресурсы, на которые она могла подписаться во время `update` или `render`, чтобы предотвратить утечки памяти.

- `reconnected()`: Вызывается, когда ранее отключенная директива возвращается в использование. Поскольку поддеревья DOM могут временно отключаться и затем снова подключаться, отключенная директива может потребовать реакцию
  на повторное подключение. Примеры этого включают удаление и кэширование DOM для последующего использования или перемещение хост-элемента, вызывающее отключение и повторное подключение. Обратный вызов `reconnected()`
  всегда должен реализовываться вместе с `disconnected()`, чтобы восстановить отключенную директиву в рабочее состояние.

- `isConnected`: Отражает текущее состояние подключения директивы.

**Важно:** Возможна ситуация, когда `AsyncDirective` продолжает получать обновления, находясь в отключенном состоянии, если его содержимое перерисовывается. Поэтому методы `update` и/или `render` всегда должны проверять
флаг `this.isConnected` перед подпиской на любые долгоживущие ресурсы, чтобы предотвратить утечки памяти.

### Пример асинхронной директивы с подпиской на Observable

```typescript
class ObserveDirective extends AsyncDirective {
  observable?: Observable<unknown>
  unsubscribe?: () => void

  // При изменении observable отписывается от старого и подписывается на новое
  render(observable: Observable<unknown>) {
    if (this.observable !== observable) {
      this.unsubscribe?.()
      this.observable = observable
      if (this.isConnected) {
        this.subscribe(observable)
      }
    }
    return noChange
  }

  // Подписывается на observable, вызывая асинхронный метод setValue каждый раз, когда значение изменяется
  subscribe(observable: Observable<unknown>) {
    this.unsubscribe = observable.subscribe((v: unknown) => {
      this.setValue(v)
    })
  }

  // Когда директива отключена от DOM, отписывается, чтобы обеспечить сборку мусора
  disconnected() {
    this.unsubscribe!()
  }

  // Если поддерево, содержащее директиву, было отключено и затем повторно подключено, повторно подписывается
  reconnected() {
    this.subscribe(this.observable!)
  }
}

export const observe = directive(ObserveDirective)
```

Здесь директива `ObserveDirective` подписывается на `Observable` и обновляет значение асинхронно каждый раз, когда наблюдаемое значение изменяется. Методы `disconnected` и `reconnected` обеспечивают правильную подписку и
отписку, предотвращая утечки памяти.
