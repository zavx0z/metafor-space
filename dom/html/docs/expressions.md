# Выражения

## Содержание

1. [Дочерние выражения](#дочерние-выражения)
    1. [Примитивные значения](#примитивные-значения)
    2. [Значения Sentinel](#значения-sentinel)
    3. [Шаблоны](#шаблоны)
    4. [DOM-узлы](#dom-узлы)
    5. [Массивы или итерируемые объекты любого из поддерживаемых типов](#массивы-или-итерируемые-объекты-любого-из-поддерживаемых-типов)
    6. [Удаление дочернего содержимого](#удаление-дочернего-содержимого)
2. [Выражения атрибутов](#выражения-атрибутов)
    1. [Логические атрибуты](#логические-атрибуты)
    2. [Удаление атрибута](#удаление-атрибута)
3. [Выражения свойств](#выражения-свойств)
4. [Выражения обработчиков событий](#выражения-обработчиков-событий)
5. [Выражения для элементов](#выражения-для-элементов)
6. [Правильно сформированный HTML](#правильно-сформированный-html)
7. [Допустимые местоположения выражений](#допустимые-местоположения-выражений)
    1. [Неверные местоположения](#неверные-местоположения)
8. [Статические выражения](#статические-выражения)
    1. [Структура шаблона](#структура-шаблона)
    2. [Небуквальная статика](#небуквальная-статика)

Шаблоны могут включать динамические значения, называемые выражениями. Выражение может быть любым выражением JavaScript. Выражение вычисляется при вычислении шаблона, а результат выражения включается при рендеринге шаблона.
В компоненте @metafor/html это означает всякий раз, когда render вызывается метод.

Выражения могут быть размещены только в определенных местах шаблона, и то, как выражение интерпретируется, зависит от того, где оно появляется. Выражения внутри самого тега элемента влияют на элемент. Выражения внутри
содержимого элемента, куда попадают дочерние узлы, отображают дочерние узлы или текст.

Допустимые значения для выражений различаются в зависимости от того, где встречается выражение. Обычно все выражения принимают примитивные значения, такие как строки и числа, а некоторые выражения поддерживают
дополнительные типы значений. Кроме того, все выражения могут принимать директивы, которые являются специальными функциями, настраивающими способ обработки и отображения выражения. Для получения дополнительной информации
см. [Пользовательские директивы](./custom-directives.md).

Ниже приведена краткая справка, за которой следует более подробная информация о каждом типе выражения.

## Таблица с примерами

| Тип                                                   | Пример                                                        |
|-------------------------------------------------------|---------------------------------------------------------------|
| [Дочерние узлы](#child-expressions)                   | `` html`<h1>Hello ${name}</h1><ul>${listItems}</ul>`  ``      |
| [Атрибуты](#attribute-expressions)                    | `` html`<div class=${highlightClass}></div>`  ``              |
| [Булевы атрибуты](#boolean-attribute-expressions)     | `` html`<div ?hidden=${!show}></div>`  ``                     |
| [Характеристики](#property-expressions)               | `` html`<input .value=${value}>`  ``                          |
| [Прослушиватели событий](#event-listener-expressions) | `` html`<button @click=${this._clickHandler}>Go</button>`  `` |
| [Директивы элементов](#element-expressions)           | `` html`<input ${ref(inputRef)}>`  ``                         |

Этот простой пример демонстрирует множество различных видов выражений.

```javascript
html`
  <p>
    ${this.greeting}
    <button @click=${() => (this.show = !this.show)}>Todos</button>
  </p>
  ${this.show
  ? html`
        <ul>
          ${this.todos.map(
    i =>
      html`
                <li>${i}</li>
              `
  )}
        </ul>
      `
  : ""}
`
```

# Дочерние выражения

## Дочерние выражения

Выражения, которые находятся между начальным и конечным тегами элемента, могут добавлять дочерние узлы в этот элемент. Например:

```javascript
html`
  <p>Привет, ${name}</p>
`
```

Или:

```javascript
html`
  <main>${bodyText}</main>
`
```

Выражения в позиции дочерних элементов могут принимать множество типов значений:

- Примитивные значения, такие как строки, числа и логические значения.
- Объекты `TemplateResult`, созданные с помощью функции `html` (или функции `svg`, если выражение находится внутри элемента `<svg>`).
- Узлы DOM.
- Специальные значения-сентинелы `nothing` и `noChange`.
- Массивы или итерируемые объекты, содержащие поддерживаемые типы.

---

## Примитивные значения

@metafor/html может отображать почти все примитивные значения и преобразует их в строки при интерполяции в текстовом содержимом.

- Числовые значения, такие как `5`, будут отображены как строка `'5'`. Тип `bigint` обрабатывается аналогично.
- Логическое значение `true` будет отображено как `'true'`, а `false` — как `'false'`. Однако такое отображение логических значений встречается редко. Обычно они используются в условных конструкциях для отображения других
  значений. Подробнее см. раздел [Условные конструкции](#conditionally-rendering-nothing).
- Пустая строка `''`, `null` и `undefined` обрабатываются особым образом и не отображают ничего. Подробнее см. раздел [Удаление дочернего содержимого](#удаление-дочернего-содержимого).
- Значения типа `Symbol` не могут быть преобразованы в строки и вызывают ошибку при использовании в дочерних выражениях.

---

## Значения Sentinel

@metafor/html предоставляет несколько специальных значений-сентинелов, которые можно использовать в дочерних выражениях.

- Значение `noChange` не изменяет существующее значение выражения. Обычно используется в пользовательских директивах. Подробнее см. [Сигнализация об отсутствии изменений](#signaling-no-change).
- Значение `nothing` не отображает ничего. Подробнее см. [Удаление дочернего содержимого](#удаление-дочернего-содержимого).

---

## Шаблоны

Так как выражение в позиции дочерних элементов может возвращать `TemplateResult`, можно вкладывать и компоновать шаблоны:

```javascript
const nav = html`
  <nav>...</nav>
`
const page = html`
  ${nav}
  <main>...</main>
`
```

Это позволяет использовать чистый JavaScript для создания условных шаблонов, повторяющихся шаблонов и других конструкций:

```javascript
html`
  ${this.user.isloggedIn
  ? html`
        Добро пожаловать, ${this.user.name}
      `
  : html`
        Пожалуйста, войдите в систему
      `}
`
```

Подробнее об условных конструкциях см. [Условные конструкции](#conditionally-rendering-nothing).  
Подробнее о создании списков см. [Списки](#lists).

---

## DOM-узлы

Любой узел DOM можно передать в дочернее выражение. Обычно узлы DOM следует отображать, указывая шаблон с помощью функции `html`, но узел DOM можно отобразить напрямую, если это необходимо. Узел будет прикреплён к дереву
DOM в данной точке, а также удалён из любого текущего родителя:

```javascript
const div = document.createElement("div")
const page = html`
  ${div}
  <p>Это текст</p>
`
```

---

## Массивы или итерируемые объекты любого из поддерживаемых типов

Выражение также может возвращать массив или итерируемый объект, содержащий поддерживаемые типы в любой комбинации. Вы можете использовать эту возможность вместе со стандартными методами JavaScript, такими как `Array.map`,
для создания повторяющихся шаблонов и списков. Примеры смотрите в разделе [Списки](#lists).

---

## Удаление дочернего содержимого

Значения `null`, `undefined`, пустая строка `''` и значение-сентинел `nothing` удаляют любое ранее отрендеренное содержимое и не отображают узел.

Установка или удаление дочернего содержимого часто выполняется на основе условия. Подробнее см. [Условное отображение ничего](#conditionally-rendering-nothing).

Не отображение узла может быть важным, если выражение является дочерним элементом в Shadow DOM, содержащем слот с резервным содержимым. Не отображение узла гарантирует отображение резервного содержимого. Подробнее
см. [Резервное содержимое](#fallback-content).

---

# Выражения атрибутов

## Выражения атрибутов

Помимо использования выражений для добавления дочерних узлов, их можно использовать для установки атрибутов и свойств элементов.

По умолчанию выражение в значении атрибута задаёт атрибут:

```javascript
html`
  <div class=${this.textClass}>Стильный текст.</div>
`
```

Поскольку значения атрибутов всегда являются строками, выражение должно возвращать значение, которое можно преобразовать в строку.

Если выражение полностью заменяет значение атрибута, кавычки можно опустить. Если же выражение является лишь частью значения атрибута, необходимо заключить всё значение в кавычки:

```javascript
html`
  <img src="/images/${this.image}" />
`
```

Некоторые примитивные значения обрабатываются особым образом в атрибутах:

- Логические значения преобразуются в строки: `false` рендерится как `'false'`.
- `undefined` и `null` рендерятся как пустая строка.

---

## Логические атрибуты

Чтобы задать логический атрибут, используйте префикс `?` перед именем атрибута. Атрибут добавляется, если выражение вычисляется в значение, приводимое к `true`, и удаляется, если выражение оценивается как `false`:

```javascript
html`
  <div ?hidden=${!this.showAdditional}>Этот текст может быть скрыт.</div>
`
```

---

## Удаление атрибута

Иногда требуется задавать атрибут только при выполнении определённых условий, а в противном случае удалять его. Для часто используемых "логических атрибутов", таких как `disabled` и `hidden`, можно установить значение
атрибута в пустую строку при истинном значении и удалить его в противном случае.

Например:

```javascript
html`
  <img src="/images/${this.imagePath}/${this.imageFile}" />
`
```

Если `this.imagePath` или `this.imageFile` не определены, атрибут `src` не должен быть задан, иначе произойдёт недопустимый сетевой запрос.

Для решения этой задачи используется значение-сентинел `nothing`, которое удаляет атрибут, если любое выражение в значении атрибута оценивается в `nothing`:

```javascript
html`
  <img src="/images/${this.imagePath ?? nothing}/${this.imageFile ?? nothing}" />
`
```

В этом примере оба свойства `this.imagePath` и `this.imageFile` должны быть определены, чтобы атрибут `src` был установлен. Оператор ?? возвращает правое значение, если левое значение равно `null` или `undefined`.

---

### Директива `ifDefined`

@metafor/html также предоставляет директиву `ifDefined`, которая упрощает использование `value ?? nothing`:

```javascript
html`
  <img src="/images/${ifDefined(this.imagePath)}/${ifDefined(this.imageFile)}" />
`
```

---

### Удаление атрибута для ложных значений

Вы также можете удалить атрибут, если значение не приводится к `true`. Например, если у элемента есть значение по умолчанию `this.ariaLabel` в виде пустой строки:

```javascript
html`
  <button aria-label="${this.ariaLabel || nothing}"></button>
`
```

В этом примере атрибут `aria-label` будет отображён только если `this.ariaLabel` не является пустой строкой.

---

Установка или удаление атрибута часто выполняется на основе условия. Подробнее см. [Условное отображение ничего](#conditionally-rendering-nothing).

---

# Выражения свойств

## Установка свойств

Вы можете установить JavaScript-свойство элемента, используя префикс `.` перед именем свойства:

```javascript
html`<input .value=${this.itemCount}>`;
```

Поведение кода выше идентично прямой установке свойства `value` у элемента `input`, например:

```javascript
inputEl.value = this.itemCount;
```

---

## Передача сложных данных

Синтаксис выражения свойства можно использовать для передачи сложных данных по дереву компонентов. Например, если у вас есть компонент `my-list` со свойством `listItems`, вы можете передать ему массив объектов:

```javascript
html`<my-list .listItems=${this.items}></my-list>`;
```

Обратите внимание, что имя свойства в этом примере — `listItems` — написано в смешанном регистре (camelCase). Хотя HTML-атрибуты не чувствительны к регистру, @metafor/html сохраняет регистр для имён свойств при обработке шаблона.

---

## Дополнительная информация

Для получения более подробной информации о свойствах компонентов см. раздел [Реактивные свойства](#reactive-properties).

---

```markdown
# Выражения обработчиков событий

## Декларативные обработчики событий

Шаблоны могут включать декларативные обработчики событий. Используйте префикс `@` перед именем события. Выражение должно оцениваться в обработчик события.

```javascript
html`<button @click=${this.clickHandler}>Нажми меня!</button>`;
```

Это аналогично вызову `addEventListener('click', this.clickHandler)` на элементе кнопки.

Обработчик события может быть либо обычной функцией, либо объектом с методом `handleEvent`, как аргумент `listener` в стандартном методе `addEventListener`.

---

## Привязка к контексту компонента

В @metafor/html-компоненте обработчик события автоматически привязывается к компоненту, поэтому вы можете использовать значение `this` внутри обработчика для ссылки на экземпляр компонента.

```javascript
clickHandler()
{
  this.clickCount++;
}
```

Для получения дополнительной информации о событиях компонентов см. раздел [События](#events).

---

# Выражения элементов

## Доступ к экземпляру элемента

Вы можете добавить выражение, которое обращается к экземпляру элемента, вместо отдельного свойства или атрибута элемента:

```javascript
html`<div ${myDirective()}></div>`;
```

Выражения элементов работают только с директивами. Любое другое значение в выражении элемента игнорируется.

---

## Директива `ref`

Одной из встроенных директив, которую можно использовать в выражении элемента, является директива `ref`. Она предоставляет ссылку на отрендеренный элемент.

```javascript
html`<button ${ref(this.myRef)}></button>`;
```

См. раздел [ref](#ref) для получения дополнительной информации.

---

# Корректное HTML

## Правила для корректных шаблонов

Шаблоны @metafor/html должны быть корректным HTML, поскольку они парсятся встроенным HTML-парсером браузера перед интерполяцией значений. Следуйте этим правилам:

1. **Шаблоны должны быть корректным HTML** даже в случае замены всех выражений на пустые значения.
2. Шаблоны могут иметь несколько верхнеуровневых элементов и текста.
3. **Элементы должны быть закрыты** — незакрытые элементы автоматически закрываются HTML-парсером.

### Пример некорректного HTML

```javascript
// HTML-парсер закроет этот div после "Некоторый текст"
const template1 = html`<div class="broken-div">Некоторый текст`;
// При объединении "ещё текст" не окажется внутри .broken-div
const template2 = html`${template1} ещё текст. </div>`;
```

---

## Рекомендации

> Так как встроенный парсер браузера очень снисходителен, большинство случаев некорректных шаблонов не обнаруживаются во время выполнения, что может привести к неожиданному поведению. Мы рекомендуем использовать
> инструменты линтинга и плагины для IDE, чтобы находить проблемы в шаблонах на этапе разработки.

---

# Допустимые местоположения выражений

## Выражения в атрибутах

Выражения можно использовать в тех местах, где могут быть расположены значения атрибутов в HTML:

```html
<!-- Значения атрибутов -->
<div label=${label}></div>
<button ?disabled=${isDisabled}>Нажми меня!</button>
<input .value=${currentValue}>
<button @click=${this.handleClick()}>
```

## Выражения в содержимом элемента

Выражения также могут находиться внутри элементов как дочерний контент:

```html
<!-- Дочерний контент -->
<div>${textContent}</div>
```

## Выражения внутри открывающего тега

Выражения элементов могут быть использованы внутри открывающего тега после имени тега:

```html

<div ${ref(elementReference)}></div>
```

---

# Недопустимые местоположения выражений

## Динамические имена тегов или атрибутов

Выражения не могут использоваться там, где должны быть имена тегов или атрибутов. @metafor/html не поддерживает динамическое обновление таких значений и выдаст ошибку в режиме разработки:

```html
<!-- Ошибка -->
<${tagName}></${tagName}>
<div ${attrName}=true></div>
```

## Внутри содержимого элемента `<template>`

Выражения внутри содержимого элемента `<template>` не поддерживаются. Однако выражения в атрибутах самого `<template>` разрешены:

```html
<!-- Ошибка -->
<template>${content}</template>

<!-- Разрешено -->
<template id="${attrValue}">статическое содержимое</template>
```

## Внутри содержимого элемента `<textarea>`

@metafor/html может рендерить контент в `<textarea>`, но редактирование содержимого приведет к разрыву ссылок на DOM, используемых для динамического обновления. Вместо этого используйте привязку к свойству `.value`:

```html
<!-- Осторожно -->
<textarea>${content}</textarea>

<!-- Разрешено -->
<textarea .value=${content}></textarea>
<textarea id="${attrValue}">статическое содержимое</textarea>
```

## Внутри элементов с атрибутом `contenteditable`

Подобно `<textarea>`, элементы с `contenteditable` не поддерживают динамическое обновление выражений в содержимом. Используйте привязку к свойству `.innerText`:

```html
<!-- Осторожно -->
<div contenteditable>${content}</div>

<!-- Разрешено -->
<div contenteditable .innerText=${content}></div>
<div contenteditable id="${attrValue}">статическое содержимое</div>
```

## Внутри HTML-комментариев

@metafor/html не обновляет выражения в комментариях. Такие выражения будут отрендерены как строка токена Lit, но это не повлияет на последующие выражения. Поэтому закомментировать блоки HTML, содержащие выражения, безопасно во время
разработки:

```html
<!-- не обновится: ${value} -->
```

## Внутри элементов `<style>` при использовании ShadyCSS

Для получения дополнительной информации см. раздел [Выражения и элементы стиля](#expressions-and-style-elements).

---


Во всех перечисленных выше недопустимых случаях выражения допустимы при использовании статических выражений. Однако статические выражения не рекомендуются для часто обновляемых данных из-за их низкой производительности.

---

# Статические выражения

## Описание

Статические выражения возвращают специальные значения, которые интерполируются в шаблон до того, как он обрабатывается @metafor/html как HTML. Поскольку они становятся частью статического HTML-шаблона, их можно размещать в любом
месте шаблона, даже там, где обычные выражения запрещены, например в именах атрибутов или тегов.

Для использования статических выражений необходимо импортировать специальную версию функций шаблонов `html` или `svg` из модуля `@metafor/html/static-html.js`:

```javascript
import {html, literal} from '@pkg/html/static-html.js';
```

Этот модуль предоставляет функции `html` и `svg`, поддерживающие статические выражения, которые следует использовать вместо стандартных версий из модуля `@metafor/html`. Используйте функцию `literal` для создания статических
выражений.

---

## Пример

Статические выражения подходят для редко изменяющихся настроек или для кастомизации частей шаблона, которые невозможно изменить с помощью обычных выражений. Например, компонент `my-button` может использовать `<button>` или
`<a>` в зависимости от класса:

```javascript
import {LitElement} from '@pkg/html';
import {html, literal} from '@pkg/html/static-html.js';

class MyButton extends LitElement {
  static properties = {
    caption: {},
    active: {type: Boolean},
  };

  tag = literal`button`;
  activeAttribute = literal`active`;

  constructor() {
    super();
    this.caption = 'Hello static';
    this.active = false;
  }

  render() {
    return html`
      <${this.tag} ${this.activeAttribute}=${this.active}>
        <p>${this.caption}</p>
      </${this.tag}>`;
  }
}

customElements.define('my-button', MyButton);

class MyAnchor extends MyButton {
  tag = literal`a`;
}

customElements.define('my-anchor', MyAnchor);
```

---

## Ограничения

Изменение значений статических выражений требует больших затрат. Если значения `literal` часто меняются, @metafor/html создаёт новый шаблон, что неэффективно. Это приводит к полной перерисовке DOM и увеличению использования памяти,
так как уникальные шаблоны кэшируются для улучшения производительности.

В примере выше изменения `this.caption` или `this.active` обрабатываются эффективно. Однако изменения `this.tag` или `this.activeAttribute` создают новый шаблон, из-за чего производительность падает.

### Рекомендации:

- Минимизируйте изменения выражений с использованием `literal`.
- Избегайте использования реактивных свойств для изменения значений `literal`.

---

## Структура шаблона

После интерполяции статических значений шаблон должен быть корректно сформирован, как обычные шаблоны @metafor/html. В противном случае динамические выражения могут работать некорректно. Подробнее см.
раздел [Корректный HTML](#well-formed-html).

---

## Нестандартные статические выражения

В редких случаях нужно интерполировать статический HTML, который не определён в скрипте. Для этого можно использовать функцию `unsafeStatic()`:

```javascript
import {html, unsafeStatic} from '@pkg/html/static-html.js';
```

### Важно:

Строки, передаваемые в `unsafeStatic()`, должны быть доверенными, так как они парсятся напрямую без какой-либо очистки. Использование непроверенного содержимого (например, пользовательских данных) может привести к
уязвимостям XSS.

---

## Пример с `unsafeStatic`

```javascript
class MyButton extends LitElement {
  static properties = {
    caption: {},
    active: {type: Boolean},
  };

  constructor() {
    super();
    this.caption = 'Hello static';
    this.active = false;
  }

  render() {
    // Строки должны быть доверенными, иначе возможна уязвимость XSS
    const tag = getTagName();
    const activeAttribute = getActiveAttribute();
    return html`
      <${unsafeStatic(tag)} ${unsafeStatic(activeAttribute)}=${this.active}>
        <p>${this.caption}</p>
      </${unsafeStatic(tag)}>`;
  }
}

customElements.define('my-button', MyButton);
```

### Замечания:

- Использование `unsafeStatic` имеет те же ограничения, что и `literal`: изменения значений приводят к созданию нового шаблона, что увеличивает затраты памяти и снижает производительность.
- Избегайте частого изменения значений, используемых с `unsafeStatic`.