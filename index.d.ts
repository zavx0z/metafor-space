/**
 * # MetaFor Framework
 * 
 * MetaFor — это фреймворк для управления состояниями в виде конечных автоматов,
 * где **Контекст** служит единственным источником истины, а все переходы 
 * между состояниями происходят автоматически по триггерам.
 * 
 * ## Архитектура фреймворка
 * 
 * ### Основные компоненты:
 * 
 * 1. **Частица (Particle)** — основная единица в MetaFor
 *    - Имеет уникальный идентификатор, состояние, контекст, действия, переходы, ядро, реакции и представление
 * 
 * 2. **Состояния (States)** — определяют возможные состояния частицы
 *    - Каждая частица должна находиться в одном из предопределенных состояний
 * 
 * 3. **Контекст (Context)** — содержит данные, связанные с частицей
 *    - Определяется с помощью типизированного объекта и типов данных
 * 
 * 4. **Переходы (Transitions)** — правила перехода между состояниями
 *    - Каждый переход содержит исходное состояние, возможные целевые состояния с триггерами,
 *      и опционально действие, которое будет выполнено при входе в новое состояние
 * 
 * 5. **Действия (Actions)** — функции, выполняемые при входе в определенное состояние
 *    - Могут изменять контекст и вызывать переходы между состояниями
 * 
 * 6. **Ядро (Core)** — предоставляет доступ к сервисам и ресурсам
 *    - Сюда включаются API-запросы, таймеры, локальное хранилище и т.д.
 * 
 * 7. **Реакции (Reactions)** — позволяют частицам реагировать на изменения в других частицах
 *    - Определяют взаимодействие между различными частицами
 * 
 * 8. **Представление (View)** — определяет визуальный компонент, связанный с частицей
 *    - Автоматически обновляется при изменении состояния или контекста частицы
 * 
 * ## Жизненный цикл частицы
 * 
 * ### Общие принципы
 * 
 * - **Контекст как единственный источник истины**
 *   - Все процессы в частице работают в едином контексте
 *   - Контекст можно обновлять в любой момент через метод `update(...)`
 *   - Любые изменения контекста могут привести к автоматическим переходам между состояниями
 * 
 * - **Триггеры и переходы между состояниями**
 *   - При входе в состояние с привязанным действием (Action) триггеры временно блокируются
 *   - Контекст может обновляться даже в заблокированном состоянии, но переход не произойдёт
 *   - После завершения действий триггеры разблокируются, и система реагирует на обновления
 * 
 * ### Этапы жизненного цикла
 * 
 * #### 1. Инициализация
 * 
 * Пример инициализации частицы:
 * 
 * @example
 * ```js
 * const todoParticle = MetaFor("todo-list")
 *   .states("IDLE", "LOADING", "SUCCESS", "ERROR")
 *   .context((t) => ({
 *     items: t.array({ default: [] }),
 *     isLoading: t.boolean({ default: false }),
 *     error: t.string({ default: null }),
 *   }))
 *   .transitions([...])
 *   .actions({...})
 *   .create({
 *     state: "IDLE", // Начальное состояние
 *     context: {
 *       // Начальный контекст (опционально)
 *       items: [],
 *     },
 *   })
 * ```
 * 
 * - Устанавливается начальное состояние и контекст
 * - Если в начальном состоянии есть привязанное действие, оно выполняется автоматически
 * 
 * #### 2. Выполнение действий (Actions)
 * 
 * - Действия автоматически вызываются при входе в состояние, если они указаны в конфигурации
 * - Внутри действия можно обращаться к Core для работы с ресурсами (сети, таймеры и т.д.)
 * - Можно вызывать `update(...)` для изменения контекста
 * - Можно использовать `setState(...)` для явного перехода в другое состояние
 * 
 * > **Важно:** Actions не могут вызываться извне напрямую — только автоматически при входе в состояние
 * 
 * #### 3. Переходы между состояниями (Transitions)
 * 
 * - После окончания действия система проверяет: какой триггер удовлетворён при текущем контексте?
 * - Если триггер срабатывает, совершается переход в новое состояние (возможно, с новым Action)
 * - Переходы могут происходить каскадно, если после перехода сразу срабатывает другой триггер
 * 
 * #### 4. Внешние обновления контекста
 * 
 * - Любое обновление контекста может привести к автоматическому переходу, если выполнены условия триггера
 * - Обновления контекста не блокируются, даже если частица находится в процессе выполнения действия
 * 
 * ### Практические рекомендации
 * 
 * 1. **Используйте контекст как единственный источник истины** — все данные должны храниться в контексте
 * 2. **Делегируйте асинхронные операции в Actions** — не выполняйте их напрямую в обработчиках событий
 * 3. **Определяйте чёткие условия переходов** — триггеры должны быть понятными и предсказуемыми
 * 4. **Используйте Core для работы с внешними ресурсами** — это упрощает тестирование и поддержку кода
 * 5. **Обновляйте контекст только через `update()`** — не модифицируйте контекст напрямую
 * 6. **Используйте реакции для связи между частицами** — это обеспечивает слабую связность кода
 * 7. **Разделяйте логику и представление** — бизнес-логика в частице, отображение во View
 */

import type { Snapshot } from "./types"
import type { ParticleConstructorParams } from "./types/metafor"
import type {
  ContextDefinition,
  ContextTypes,
  UpdateParameters,
  OnUpdateContextData,
  ContextData,
} from "./types/context"
import type { Transitions } from "./types/transition"
import type { CoreObj, CoreDefinition, Core } from "./types/core"
import type { Actions } from "./types/action"
import type { ReactionType } from "./types/reaction"
import type { ViewDefinition } from "./types/view"

import type {FabricCallbackCreateProps} from "./types/fabric";

/**
 * Конфигурация частицы
 * @property description - Описание частицы
 * @property development - Режим разработки (подключена валидация)
 */
export type ParticleConf = {
  description?: string
  development?: boolean
}

/**
 * Фабрика частиц пространства MetaFor
 * 
 * MetaFor — это фреймворк для управления состояниями в виде конечных автоматов,
 * где **Контекст** служит единственным источником истины, а все переходы 
 * между состояниями происходят автоматически по триггерам.
 * 
 * ## Архитектура фреймворка
 * 
 * ### Основные компоненты:
 * 
 * 1. **Частица (Particle)** — основная единица в MetaFor
 *    - Имеет уникальный идентификатор, состояние, контекст, действия, переходы, ядро, реакции и представление
 * 
 * 2. **Состояния (States)** — определяют возможные состояния частицы
 *    - Каждая частица должна находиться в одном из предопределенных состояний
 * 
 * 3. **Контекст (Context)** — содержит данные, связанные с частицей
 *    - Определяется с помощью типизированного объекта и типов данных
 * 
 * 4. **Переходы (Transitions)** — правила перехода между состояниями
 *    - Каждый переход содержит исходное состояние, возможные целевые состояния с триггерами,
 *      и опционально действие, которое будет выполнено при входе в новое состояние
 * 
 * 5. **Действия (Actions)** — функции, выполняемые при входе в определенное состояние
 *    - Могут изменять контекст и вызывать переходы между состояниями
 * 
 * 6. **Ядро (Core)** — предоставляет доступ к сервисам и ресурсам
 *    - Сюда включаются API-запросы, таймеры, локальное хранилище и т.д.
 * 
 * 7. **Реакции (Reactions)** — позволяют частицам реагировать на изменения в других частицах
 *    - Определяют взаимодействие между различными частицами
 * 
 * 8. **Представление (View)** — определяет визуальный компонент, связанный с частицей
 *    - Автоматически обновляется при изменении состояния или контекста частицы
 *
 * @param tag - Имя частицы
 * @param conf - Конфигурация частицы
 * @returns Интерфейс для конфигурации частицы
 * 
 * @example
 * ```js
 * const todoParticle = MetaFor("todo-list")
 *   .states("IDLE", "LOADING", "SUCCESS", "ERROR")
 *   .context((t) => ({
 *     items: t.array({ default: [] }),
 *     isLoading: t.boolean({ default: false }),
 *     error: t.string({ default: null }),
 *   }))
 *   .transitions([...])
 *   .actions({...})
 *   .create({
 *     state: "IDLE", // Начальное состояние
 *     context: {
 *       // Начальный контекст (опционально)
 *       items: [],
 *     },
 *   })
 * ```
 */ // prettier-ignore
export declare function MetaFor(tag: string, conf?: ParticleConf): {
    /**
     * Все возможные состояния частицы
     * 
     * Состояния определяют возможные состояния частицы, в которых она может находиться.
     * Каждая частица должна находиться в одном из предопределенных состояний.
     * 
     * @example
     * ```js
     * .states("IDLE", "LOADING", "SUCCESS", "ERROR")
     * ```
     */
    states: <S extends string>( ...states: S[]) => {
        /**
         * Контекст частицы
         * 
         * Контекст содержит данные, связанные с частицей.
         * Определяется с помощью типизированного объекта и типов данных.
         * 
         * ## Общие принципы
         * 
         * - **Контекст как единственный источник истины**
         *   - Все процессы в частице работают в едином контексте
         *   - Контекст можно обновлять в любой момент через метод `update(...)`
         *   - Любые изменения контекста могут привести к автоматическим переходам между состояниями
         *   
         * @example
         * ```js
         * .context((t) => ({
         *   items: t.array({ default: [] }),
         *   isLoading: t.boolean({ default: false }),
         *   error: t.string({ default: null }),
         * }))
         * ```
         */
        context: <C extends ContextDefinition>(context: (types: ContextTypes) => C) => {
            /**
             * Переходы между состояниями
             * 
             * Правила перехода между состояниями.
             * Каждый переход содержит исходное состояние, возможные целевые состояния с триггерами,
             * и опционально действие, которое будет выполнено при входе в новое состояние.
             * 
             * ## Триггеры и переходы между состояниями
             * 
             * - При входе в состояние с привязанным действием (Action) триггеры временно блокируются
             * - Контекст может обновляться даже в заблокированном состоянии, но переход не произойдёт
             * - После завершения действий триггеры разблокируются, и система реагирует на обновления
             * 
             * ### Процесс переходов
             * 
             * - После окончания действия система проверяет: какой триггер удовлетворён при текущем контексте?
             * - Если триггер срабатывает, совершается переход в новое состояние (возможно, с новым Action)
             * - Переходы могут происходить каскадно, если после перехода сразу срабатывает другой триггер
             */
            transitions: (transitions: Transitions<C, S>) => {
                /**
                 * Ядро частицы
                 * 
                 * Предоставляет доступ к сервисам и ресурсам.
                 * Сюда включаются API-запросы, таймеры, локальное хранилище и т.д.
                 * 
                 * ### Рекомендации по работе с ядром
                 * 
                 * - Используйте Core для работы с внешними ресурсами — это упрощает тестирование и поддержку кода
                 */
                core: <I extends CoreObj>(core: CoreDefinition<I, C> = () => Object.create({})) => {
                    /**
                     * Действия частицы
                     * 
                     * Функции, выполняемые при входе в определенное состояние.
                     * Могут изменять контекст и вызывать переходы между состояниями.
                     * 
                     * ### Особенности работы действий
                     * 
                     * - Действия автоматически вызываются при входе в состояние, если они указаны в конфигурации
                     * - Внутри действия можно обращаться к Core для работы с ресурсами (сети, таймеры и т.д.)
                     * - Можно вызывать `update(...)` для изменения контекста
                     * - Можно использовать `setState(...)` для явного перехода в другое состояние
                     * 
                     * > **Важно:** Actions не могут вызываться извне напрямую — только автоматически при входе в состояние
                     * 
                     * ### Рекомендации по работе с действиями
                     * 
                     * - Делегируйте асинхронные операции в Actions — не выполняйте их напрямую в обработчиках событий
                     */
                    actions: (actions: Actions<C, I>) => {
                        /**
                         * Реакции на изменения других частиц
                         * 
                         * Позволяют частицам реагировать на изменения в других частицах.
                         * Определяют взаимодействие между различными частицами.
                         * 
                         * ### Рекомендации по работе с реакциями
                         * 
                         * - Используйте реакции для связи между частицами — это обеспечивает слабую связность кода
                         */
                        reactions: (reactions: ReactionType<C, I>) => {
                            /**
                             * Представление отображения частицы
                             * 
                             * Определяет визуальный компонент, связанный с частицей.
                             * Автоматически обновляется при изменении состояния или контекста частицы.
                             * 
                             * ### Рекомендации по работе с представлением
                             * 
                             * - Разделяйте логику и представление — бизнес-логика в частице, отображение во View
                             */
                            view: (view: ViewDefinition<I, C, S>) => {
                                /**
                                 * Создание базовой частицы с:
                                 * - реакциями
                                 * - представлением отображения
                                 * 
                                 * ### Инициализация
                                 * 
                                 * - Устанавливается начальное состояние и контекст
                                 * - Если в начальном состоянии есть привязанное действие, оно выполняется автоматически
                                 */
                                create: (data: FabricCallbackCreateProps<C, S, I>) => Particle<S, C, I>
                            }
                            /**
                             * Создание частицы с:
                             * - реакциями
                             * 
                             * ### Инициализация
                             * 
                             * - Устанавливается начальное состояние и контекст
                             * - Если в начальном состоянии есть привязанное действие, оно выполняется автоматически
                             */
                            create: (data: FabricCallbackCreateProps<C, S, I>) => Particle<S, C, I>
                        },
                        /**
                         * Представление отображения частицы
                         * 
                         * Определяет визуальный компонент, связанный с частицей.
                         * Автоматически обновляется при изменении состояния или контекста частицы.
                         * 
                         * ### Рекомендации по работе с представлением
                         * 
                         * - Разделяйте логику и представление — бизнес-логика в частице, отображение во View
                         */
                        view: (view: ViewDefinition<I, C, S>) => {
                            /**
                             * Создание базовой частицы с:
                             * - представлением отображения
                             * 
                             * ### Инициализация
                             * 
                             * - Устанавливается начальное состояние и контекст
                             * - Если в начальном состоянии есть привязанное действие, оно выполняется автоматически
                             */
                            create: (data: FabricCallbackCreateProps<C, S, I>) => Particle<S, C, I>
                        },
                        /**
                         * Создание базовой частицы.
                         * 
                         * ### Инициализация
                         * 
                         * - Устанавливается начальное состояние и контекст
                         * - Если в начальном состоянии есть привязанное действие, оно выполняется автоматически
                         */
                        create: (data: FabricCallbackCreateProps<C, S, I>) => Particle<S, C, I>
                    }
                }
            }
        }
    }
}

/**
 * Интерфейс частицы
 * 
 * Частица (Particle) — основная единица в MetaFor.
 * Имеет уникальный идентификатор, состояние, контекст, действия, переходы, ядро, реакции и представление.
 * 
 * ## Жизненный цикл частицы
 * 
 * ### Этапы жизненного цикла
 * 
 * 1. **Инициализация**: Устанавливается начальное состояние и контекст
 * 2. **Выполнение действий**: Действия обновляют контекст в ответ на события
 * 3. **Переходы состояний**: Контекст автоматически определяет переходы
 * 4. **Внешние обновления**: Любое обновление контекста может привести к автоматическому переходу
 * 
 * ### Внешние обновления контекста
 * 
 * - Любое обновление контекста может привести к автоматическому переходу, если выполнены условия триггера
 * - Обновления контекста не блокируются, даже если частица находится в процессе выполнения действия
 * 
 * ### Практические рекомендации
 * 
 * 1. **Используйте контекст как единственный источник истины** — все данные должны храниться в контексте
 * 2. **Обновляйте контекст только через `update()`** — не модифицируйте контекст напрямую
 * 3. **Определяйте чёткие условия переходов** — триггеры должны быть понятными и предсказуемыми
 * 
 * @template S - Состояния
 * @template C - Контекст
 * @template I - Ядро
 * @property id - Идентификатор частицы
 * @property title - Заголовок частицы
 * @property description - Описание частицы
 * @property state - Состояние частицы
 * @property context - Контекст частицы
 * @property states - Состояния частицы
 * @property types - Типы частицы
 * @property transitions - Переходы частицы
 * @property actions - Действия частицы
 * @property core - Ядро частицы
 * @property reactions - Реакции частицы
 * @property channel - Канал частицы
 * @property process - Флаг процесса частицы
 * @property component - Компонент частицы
 * @property update - Обновление частицы    
 * @property _updateExternal - Обновление частицы из вне
 * @property onUpdate - Обработчик обновления частицы
 * @property onTransition - Обработчик перехода частицы
 * @property snapshot - Снимок частицы
 * @property graph - Граф частицы
 * @property destroy - Уничтожение частицы
 */
export declare class Particle<S extends string, C extends Record<string, any>, I extends Record<string, any>> {
  id: string
  title?: string
  description?: string
  state: S
  context: ContextData<C>
  states: readonly S[]
  types: Record<string, any>
  transitions: Transitions<C, S>
  actions: Actions<C, I>
  core: Core<I>
  reactions: ReactionType<C, I>
  channel: BroadcastChannel
  process: boolean
  component: Element

  constructor(params: ParticleConstructorParams<S, C, I>)

  /**
   * Обновляет контекст частицы
   * 
   * Любое обновление контекста может привести к автоматическому переходу, 
   * если выполнены условия триггера.
   * 
   * @param context - Новые значения для контекста
   */
  update: (context: UpdateParameters<C>) => void

  /**
   * Обновляет контекст частицы из внешнего источника
   * 
   * @param params - Параметры обновления
   * @param params.context - Новые значения для контекста
   * @param params.srcName - Имя источника обновления
   * @param params.funcName - Имя функции-источника обновления
   */
  _updateExternal: (params: { context: UpdateParameters<C>; srcName?: string; funcName?: string }) => void

  /**
   * Устанавливает обработчик на обновление контекста
   * 
   * @param listener - Функция-обработчик
   * @returns Функция для удаления обработчика
   */
  onUpdate: (listener: (context: OnUpdateContextData<C>) => void) => () => void

  /**
   * Устанавливает обработчик на переход между состояниями
   * 
   * @param listener - Функция-обработчик
   * @returns Функция для удаления обработчика
   */
  onTransition: (listener: (oldState: S, newState: S) => void) => () => void

  /**
   * Создает снимок текущего состояния частицы
   * 
   * @returns Снимок состояния
   */
  snapshot: () => Snapshot<C, S>

  /**
   * Создает визуальный граф состояний и переходов
   * 
   * @returns Промис с графом
   */
  graph: () => Promise<any>

  /**
   * Уничтожает частицу и освобождает ресурсы
   */
  destroy: () => void
}
